const express = require('express');
const app = express();
const uploadRoutes = require("./src/routes/uploadRoutes");
const path = require('path');


const {Server} = require('socket.io');

const http = require('http');

const server = http.createServer(app);
const cors = require('cors');
const { timeStamp } = require('console');
const { title } = require('process');
app.use(cors());
app.use(express.json())

// Serve uploaded files statically
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

// Add uploads route
app.use("/api/uploads", uploadRoutes);

const io = new Server(server, {
    cors : {
        origin: '*',
        methods: ['GET','POST'],
    },
})


// creating a connection

const agents = [];

const  customers = {};

io.on('connection', (socket) =>{
    console.log("User connected",socket.id);
    

    socket.on('set-role',({role,username})=>{
        socket.username = username;
        socket.role = role;
        if (role === "agent") {
            agents.push({socketId: socket.id, username, status: "free"})
            console.log(`Agent joined :${username}`);
        }else{
            console.log(`Customer joined : ${username}`);
        }
    });
socket.on("sendFile", (fileInfo) => {
  console.log("Broadcasting file:", fileInfo);
  io.to(room).emit("receiveFile", fileInfo);
});

    socket.on('customer-message' , (msg) =>{
        
    // If customer already has an assigned agent, send directly
    if (customers[socket.id]) {
        const agentId = customers[socket.id];
        io.to(agentId).emit('chat-message', {
            sender: socket.username,
            text: msg,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        });

        socket.emit('chat-message', {
            sender: socket.username,
            text: msg,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        });
        return; // Don't search for new agent
    }

    //  If no agent assigned yet, find a free one
    let agent = agents.find((a) => a.status === "free");

    if (agent) {
        customers[socket.id] = agent.socketId;
        agent.status = "busy";

        // send msg to agent
        io.to(agent.socketId).emit('chat-message', {
            sender: socket.username,
            text: msg,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        });

        // also send back to the customer
        socket.emit('chat-message', {
            sender: socket.username,
            text: msg,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        });

        setTimeout(() => {
            socket.emit('chat-message',{
                sender: "System",
                text: `Agent is connected ${agent.username}`,
                time: new Date().toLocaleTimeString([],{hour:'2-digit', minute: "2-digit"})
            })
        }, 2000); 

        }else{
            socket.emit('chat-message',{
                sender: "System",
                text: "Agent are connecting , pls wait",
                time: new Date().toLocaleTimeString([],{hour: '2-digit', minute: '2-digit'})
            })
        }  
        
    })

    socket.on("sendMessage", (data) => {
    console.log("File received:", data.file);

    // If customer has an assigned agent
    if (customers[socket.id]) {
        const agentId = customers[socket.id];
        io.to(agentId).emit("chat-message", {
            sender: socket.username,
            file: data.file, // send file link/path
            time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        });

        socket.emit("chat-message", {
            sender: socket.username,
            file: data.file,
            time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        });
    } else {
        // If agent sends a file to customer
        let customerId = Object.keys(customers).find(
            (custId) => customers[custId] === socket.id
        );
        if (customerId) {
            io.to(customerId).emit("chat-message", {
                sender: socket.username,
                file: data.file,
                time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
            });

            socket.emit("chat-message", {
                sender: socket.username,
                file: data.file,
                time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
            });
        }
    }
});

    socket.on('agent-message', (msg) =>{
        let customerId = Object.keys(customers).find((custId) => customers[custId] === socket.id);

        if (customerId) {
            //send msg to the customer

            io.to(customerId).emit('chat-message',{
                sender : socket.username,
                text: msg,
                time: new Date().toLocaleTimeString([],{hour: "2-digit", minute: '2-digit'})
            });

            socket.emit('chat-message',{
                sender: socket.username,
                text: msg,
                time: new Date().toLocaleTimeString([],{hour:'2-digit', minute: "2-digit"})
            })
        }
    });

socket.on("end-message", () => {
  // if customer ends chat
  if (customers[socket.id]) {
    const agentId = customers[socket.id];
    const agent = agents.find((a) => a.socketId === agentId);
    if (agent) {
      agent.status = "free";

      // ðŸ”¹ notify agent that customer disconnected
      io.to(agentId).emit("chat-message", {
        sender: "System",
        text: "Your customer has ended the chat. Please wait for a new customer.",
        time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
      });
    }
    delete customers[socket.id];
  }

  // if agent ends chat
  else {
    const customerId = Object.keys(customers).find(
      (custId) => customers[custId] === socket.id
    );
    if (customerId) {
      // ðŸ”¹ notify customer that agent disconnected
      io.to(customerId).emit("chat-message", {
        sender: "System",
        text: "Your agent has ended the chat. Please wait for a new agent.",
        time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
      });
      delete customers[customerId];
    }
    const agent = agents.find((a) => a.socketId === socket.id);
    if (agent) agent.status = "free";
  }
});

socket.on("disconnect", () => {
  console.log(`User disconnected: ${socket.username || socket.id}`);

  // if an agent disconnected
  let agentIndex = agents.findIndex((a) => a.socketId === socket.id);
  if (agentIndex !== -1) {
    const agent = agents[agentIndex];
    agents.splice(agentIndex, 1);

    // find customer connected to this agent
    const customerId = Object.keys(customers).find(
      (custId) => customers[custId] === socket.id
    );
    if (customerId) {
      io.to(customerId).emit("chat-message", {
        sender: "System",
        text: "Your agent has disconnected. Please wait for a new agent.",
        time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
      });
      delete customers[customerId];
    }
  }

  // if a customer disconnected
  else if (customers[socket.id]) {
    const agentId = customers[socket.id];
    const agent = agents.find((a) => a.socketId === agentId);
    if (agent) {
      agent.status = "free";

      // ðŸ”¹ notify agent that customer disconnected
      io.to(agentId).emit("chat-message", {
        sender: "System",
        text: "Your customer has disconnected. Please wait for a new customer.",
        time: new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
      });
    }
    delete customers[socket.id];
  }
});



    
});

server.listen(9000, ()=>{
    console.log("Server is running on port 9000");
});
























































//



const matchmakingUtils = require("./src/utils/matchmaking");

const {
  assignAgent,
  releaseAgent,
  getFreeAgents,
  getAgentById
} = matchmakingUtils;

let chats = [];
const agents = [];
const customers = [];

module.exports = function registerSocketHandlers(io) {
  io.on("connection", (socket) => {
    console.log("ðŸ”Œ User connected:", socket.id);
    

    // --- ROLE SETUP ---
    socket.on("set-role", ({ role, username }) => {
      socket.role = role;
      socket.username = username;
    
      if (role === "agent") {
        agents.push({
          id: socket.id,
          username,
          status: "free",
          socketId: socket.id,
        });
        console.log(`âœ… Agent registered: ${username} (${socket.id})`);
      } else {
        customers.push({
          id: socket.id,
          username,
          socketId: socket.id,
        });
        console.log(`ðŸ‘¤ Customer joined: ${username} (${socket.id})`);
      }
    
      // Send list to everyone
      emitAgentList(io);
    
      // ALSO send list directly back to this socket
      socket.emit("agent-list-update", { agents: getAgentList() });
      
      // Send chat history to the newly connected user
      socket.emit("chat-history", { chats: getChatHistoryForUser(socket.id, socket.role) });
    });
    

    socket.on("request-agent-list", () => {
      console.log(`ðŸ“¤ Sending agent list to ${socket.id}`);
      socket.emit("agent-list-update", { agents: getAgentList() })
    });
    
    // --- REQUEST CHAT HISTORY ---
    socket.on("request-chat-history", () => {
      console.log(`ðŸ“¤ Sending chat history to ${socket.id}`);
      socket.emit("chat-history", { chats: getChatHistoryForUser(socket.id, socket.role) });
    });
    
    // --- LOAD SPECIFIC CHAT ---
    socket.on("load-chat", ({ chatId }) => {
      const chat = chats.find(c => c.id === chatId);
      if (chat) {
        // Check if user is authorized to view this chat
        if (isUserInChat(socket.id, socket.role, chat)) {
          socket.emit("chat-loaded", { chat });
        } else {
          socket.emit("chat-error", { message: "Not authorized to view this chat" });
        }
      } else {
        socket.emit("chat-error", { message: "Chat not found" });
      }
    });

    // --- CUSTOMER MESSAGE ---
    // In your socket handler file, update the customer-message event:
// In your socket handler file, update the customer-message event:
socket.on("customer-message", (msg) => {
  if (customers[socket.id]) {
    const agentId = customers[socket.id];
    sendMessage(io, socket, agentId, msg);
    addMessageToChat(socket.id, agentId, {
      sender: socket.id,
      senderUsername: socket.username,
      text: msg,
      time: new Date(),
      type: "text"
    });
    return;
  }

  const agent = assignAgent(agents);
  if (agent) {
    customers[socket.id] = agent.socketId;
    agent.currentCustomer = socket.id;
    agent.status = "busy";
    
    // Create a new chat
    const chatId = createChat(socket.id, agent.socketId);
    
    sendMessage(io, socket, agent.socketId, msg);
    addMessageToChat(socket.id, agent.socketId, {
      sender: socket.id,
      senderUsername: socket.username,
      text: msg,
      time: new Date(),
      type: "text"
    });

    socket.emit("chat-message", {
      sender: "System",
      text: `Agent ${agent.username} connected to you`,
      time: now(),
    });

    io.to(agent.socketId).emit("chat-message", {
      sender: "System",
      text: `You are now connected to customer ${socket.username}`,
      time: now(),
    });

    io.to(agent.socketId).emit("customer-connected", {
      customerId: socket.id,
      username: socket.username
    });

    // Update agent list for all clients
    emitAgentList(io);
    
    // Send updated chat history to both participants
    io.to(socket.id).emit("chat-history", { chats: getChatHistoryForUser(socket.id, socket.role) });
    io.to(agent.socketId).emit("chat-history", { chats: getChatHistoryForUser(agent.socketId, "agent") });

    console.log("Current customers:", customers);
  } else {
    socket.emit("chat-message", {
      sender: "System",
      text: "All agents are busy. Please wait...",
      time: now(),
    });
  }
});


// Add this to your socket handler file
// Add this to your socket handler file
socket.on("request-connection-status", () => {
  if (socket.role === "agent") {
    const customerId = Object.keys(customers).find(
      (id) => customers[id] === socket.id
    );
    if (customerId) {
      const customerSocket = io.sockets.sockets.get(customerId);
      if (customerSocket) {
        socket.emit("customer-connected", {
          customerId: customerId,
          username: customerSocket.username
        });
      }
    }
  } else if (socket.role === "customer") {
    const agentId = customers[socket.id];
    if (agentId) {
      const agent = getAgentById(agents, agentId);
      if (agent) {
        socket.emit("agent-connected", {
          agentId: agentId,
          username: agent.username
        });
      }
    }
  }
});

    // --- AGENT TRANSFER REQUEST ---
    socket.on("transfer-customer", ({ customerId, toAgentId }) => {
      if (socket.role !== "agent") return;

      const currentAgent = getAgentById(agents, socket.id);
      const targetAgent = getAgentById(agents, toAgentId);
      
      if (!currentAgent || !targetAgent || targetAgent.status !== "free") {
        socket.emit("transfer-failed", {
          message: "Transfer failed. Agent is not available."
        });
        return;
      }

      if (!customers[customerId]) {
        socket.emit("transfer-failed", {
          message: "Customer not found or not connected to any agent."
        });
        return;
      }

      if (customers[customerId] !== socket.id) {
        socket.emit("transfer-failed", {
          message: "You are not handling this customer."
        });
        return;
      }

      // Update chat with transfer information
      const chat = findChatByParticipants(socket.id, customerId);
      if (chat) {
        addMessageToChat(socket.id, customerId, {
          sender: "system",
          senderUsername: "System",
          text: `Customer transferred from ${currentAgent.username} to ${targetAgent.username}`,
          time: new Date(),
          type: "system"
        });
        
        // Add new agent to chat participants
        chat.participants.push({
          id: targetAgent.socketId,
          username: targetAgent.username,
          role: "agent"
        });
      }

      customers[customerId] = toAgentId;
      currentAgent.status = "free";
      currentAgent.currentCustomer = null;
      targetAgent.status = "busy";
      targetAgent.currentCustomer = customerId;

      io.to(customerId).emit("chat-message", {
        sender: "System",
        text: `You have been transferred to agent ${targetAgent.username}`,
        time: now(),
      });

      io.to(toAgentId).emit("chat-message", {
        sender: "System",
        text: `You received a transferred customer from ${currentAgent.username}`,
        time: now(),
      });

      const customerSocket = io.sockets.sockets.get(customerId);
      if (customerSocket) {
        io.to(toAgentId).emit("customer-connected", {
          customerId: customerId,
          username: customerSocket.username
        });
      }

      emitAgentList(io);
      console.log("Current customers:", customers);

      socket.emit("transfer-success", {
        message: `Customer successfully transferred to ${targetAgent.username}`
      });
    });

    // --- GET FREE AGENTS LIST ---
    socket.on("request-free-agents", () => {
      if (socket.role !== "agent") return;
    
      const freeAgents = getFreeAgents(agents).filter(a => a.socketId !== socket.id);
      socket.emit("free-agents-list", {
        agents: freeAgents.map(agent => ({
          id: agent.socketId,
          username: agent.username
        }))
      });
    });
    

    // --- ADMIN TRANSFER (OVERRIDE) ---
    socket.on("admin-transfer-customer", ({ customerUsername, toAgentId }) => {
      if (socket.role !== "agent") return;
      
      const targetAgent = getAgentById(agents, toAgentId);
      if (!targetAgent || targetAgent.status !== "free") {
        socket.emit("transfer-failed", {
          message: "Target agent not available for transfer."
        });
        return;
      }
      
      const customerSocket = findCustomerSocketByUsername(io, customerUsername);
      if (!customerSocket || !customers[customerSocket.id]) {
        socket.emit("transfer-failed", {
          message: "Customer not found or not connected."
        });
        return;
      }
      
      const customerId = customerSocket.id;
      const currentHandlerId = customers[customerId];
      const currentHandler = getAgentById(agents, currentHandlerId);
      
      // Update chat with transfer information
      const chat = findChatByParticipants(currentHandlerId, customerId);
      if (chat) {
        addMessageToChat(currentHandlerId, customerId, {
          sender: "system",
          senderUsername: "System",
          text: `Customer transferred from ${currentHandler.username} to ${targetAgent.username}`,
          time: new Date(),
          type: "system"
        });
        
        // Add new agent to chat participants
        chat.participants.push({
          id: targetAgent.socketId,
          username: targetAgent.username,
          role: "agent"
        });
      }
      
      customers[customerId] = toAgentId;
      
      if (currentHandler) {
        currentHandler.status = "free";
        currentHandler.currentCustomer = null;
        io.to(currentHandlerId).emit("customer-disconnected");
      }
      
      targetAgent.status = "busy";
      targetAgent.currentCustomer = customerId;
      
      io.to(customerId).emit("chat-message", {
        sender: "System",
        text: `You have been transferred to agent ${targetAgent.username}`,
        time: now(),
      });
      
      if (currentHandler) {
        io.to(currentHandlerId).emit("chat-message", {
          sender: "System",
          text: `Customer ${customerSocket.username} was transferred to ${targetAgent.username}`,
          time: now(),
        });
      }
      
      io.to(toAgentId).emit("chat-message", {
        sender: "System",
        text: `You received customer ${customerSocket.username}`,
        time: now(),
      });
      
      io.to(toAgentId).emit("customer-connected", {
        customerId: customerId,
        username: customerSocket.username
      });
      
      emitAgentList(io);
      console.log("Current customers:", customers);

      socket.emit("transfer-success", {
        message: `Customer ${customerUsername} transferred to ${targetAgent.username}`
      });
    });

    // --- AGENT MESSAGE ---
    socket.on("agent-message", (msg) => {
      const customerId = Object.keys(customers).find(
        (id) => customers[id] === socket.id
      );
      if (customerId) {
        sendMessage(io, socket, customerId, msg);
        addMessageToChat(socket.id, customerId, {
          sender: socket.id,
          senderUsername: socket.username,
          text: msg,
          time: new Date(),
          type: "text"
        });
      } else {
        socket.emit("chat-message", {
          sender: "System",
          text: "You are not connected to any customer.",
          time: now(),
        });
      }
    });

    // --- FILE MESSAGE ---
    socket.on("send-file", (data) => {
      if (socket.role === "customer") {
        const agentId = customers[socket.id];
        if (agentId) {
          sendFile(io, socket, agentId, data);
          addMessageToChat(socket.id, agentId, {
            sender: socket.id,
            senderUsername: socket.username,
            fileUrl: data.fileUrl,
            originalName: data.originalName,
            mimeType: data.mimeType,
            fileSize: data.fileSize,
            time: new Date(),
            type: "file"
          });
        }
      } else if (socket.role === "agent") {
        const customerId = Object.keys(customers).find(
          (id) => customers[id] === socket.id
        );
        if (customerId) {
          sendFile(io, socket, customerId, data);
          addMessageToChat(socket.id, customerId, {
            sender: socket.id,
            senderUsername: socket.username,
            fileUrl: data.fileUrl,
            originalName: data.originalName,
            mimeType: data.mimeType,
            fileSize: data.fileSize,
            time: new Date(),
            type: "file"
          });
        }
      }
    });

    // --- TYPING INDICATORS ---
    socket.on("typing-start", () => {
      if (socket.role === "customer" && customers[socket.id]) {
        io.to(customers[socket.id]).emit("user-typing", {
          userId: socket.id,
          username: socket.username
        });
      } else if (socket.role === "agent") {
        const customerId = Object.keys(customers).find(
          (id) => customers[id] === socket.id
        );
        if (customerId) {
          io.to(customerId).emit("user-typing", {
            userId: socket.id,
            username: socket.username
          });
        }
      }
    });

    socket.on("typing-stop", () => {
      if (socket.role === "customer" && customers[socket.id]) {
        io.to(customers[socket.id]).emit("user-stop-typing", {
          userId: socket.id
        });
      } else if (socket.role === "agent") {
        const customerId = Object.keys(customers).find(
          (id) => customers[id] === socket.id
        );
        if (customerId) {
          io.to(customerId).emit("user-stop-typing", {
            userId: socket.id
          });
        }
      }
    });

    // --- END CHAT ---
    socket.on("end-chat", () => {
      if (customers[socket.id]) {
        const agentId = customers[socket.id];
        releaseAgent(agents, agentId);
        const agent = getAgentById(agents, agentId);
        if (agent) {
          agent.currentCustomer = null;
          agent.status = "free";
        }

        // Update chat status to ended
        const chat = findChatByParticipants(agentId, socket.id);
        if (chat) {
          chat.status = "ended";
          chat.endTime = new Date();
          addMessageToChat(agentId, socket.id, {
            sender: "system",
            senderUsername: "System",
            text: "Customer ended the chat",
            time: new Date(),
            type: "system"
          });
        }

        io.to(agentId).emit("chat-message", {
          sender: "System",
          text: "Customer ended the chat.",
          time: now(),
        });
        
        io.to(agentId).emit("customer-disconnected");
        
        delete customers[socket.id];
        emitAgentList(io);
        console.log("Current customers:", customers);

      } else {
        const customerId = Object.keys(customers).find(
          (id) => customers[id] === socket.id
        );
        if (customerId) {
          // Update chat status to ended
          const chat = findChatByParticipants(socket.id, customerId);
          if (chat) {
            chat.status = "ended";
            chat.endTime = new Date();
            addMessageToChat(socket.id, customerId, {
              sender: "system",
              senderUsername: "System",
              text: "Agent ended the chat",
              time: new Date(),
              type: "system"
            });
          }
          
          io.to(customerId).emit("chat-message", {
            sender: "System",
            text: "Agent ended the chat.",
            time: now(),
          });
          delete customers[customerId];
        }
        releaseAgent(agents, socket.id);
        const agent = getAgentById(agents, socket.id);
        if (agent) {
          agent.currentCustomer = null;
          agent.status = "free";
        }

        io.to(socket.id).emit("customer-disconnected");
        emitAgentList(io);
        console.log("Current customers:", customers);
      }
      
      // Notify all users of updated chat history
      io.emit("chat-history", { chats: getAllChats() });
    });

    // --- DISCONNECT ---
    socket.on("disconnect", () => {
      console.log(`âŒ Disconnected: ${socket.username || socket.id}`);

      const agentIndex = agents.findIndex((a) => a.socketId === socket.id);
      if (agentIndex !== -1) {
        const agent = agents[agentIndex];
        const customerId = Object.keys(customers).find(
          (id) => customers[id] === socket.id
        );
        if (customerId) {
          // Update chat status to ended
          const chat = findChatByParticipants(socket.id, customerId);
          if (chat) {
            chat.status = "ended";
            chat.endTime = new Date();
            addMessageToChat(socket.id, customerId, {
              sender: "system",
              senderUsername: "System",
              text: "Agent disconnected",
              time: new Date(),
              type: "system"
            });
          }
          
          io.to(customerId).emit("chat-message", {
            sender: "System",
            text: "Agent disconnected. Please wait for another agent.",
            time: now(),
          });
          delete customers[customerId];
        }
        
        agents.splice(agentIndex, 1);
        emitAgentList(io);
        console.log("Current customers:", customers);
        
      } else if (customers[socket.id]) {
        const agentId = customers[socket.id];
        releaseAgent(agents, agentId);
        const agent = getAgentById(agents, agentId);
        if (agent) {
          agent.currentCustomer = null;
          agent.status = "free";
        }

        // Update chat status to ended
        const chat = findChatByParticipants(agentId, socket.id);
        if (chat) {
          chat.status = "ended";
          chat.endTime = new Date();
          addMessageToChat(agentId, socket.id, {
            sender: "system",
            senderUsername: "System",
            text: "Customer disconnected",
            time: new Date(),
            type: "system"
          });
        }

        io.to(agentId).emit("chat-message", {
          sender: "System",
          text: "Customer disconnected.",
          time: now(),
        });
        
        io.to(agentId).emit("customer-disconnected");
        
        delete customers[socket.id];
        emitAgentList(io);
        console.log("Current customers:", customers);
      }
      
      // Notify all users of updated chat history
      io.emit("chat-history", { chats: getAllChats() });
    });

    socket.on("ping", () => {
      socket.emit("pong");
    });
  });

  // --- Helper Functions ---
  function sendMessage(io, socket, targetId, text) {
    const payload = { 
      sender: socket.username, 
      text, 
      time: now(),
      type: "text"
    };
    io.to(targetId).emit("chat-message", payload);
    socket.emit("chat-message", payload);
  }

  function sendFile(io, socket, targetId, fileData) {
    const payload = { 
      sender: socket.username, 
      fileUrl: fileData.fileUrl, 
      originalName: fileData.originalName,
      mimeType: fileData.mimeType,
      fileSize: fileData.fileSize,
      time: now(),
      type: "file"
    };
    io.to(targetId).emit("chat-message", payload);
    socket.emit("chat-message", payload);
  }

  function getAgentList() {
    return agents.map(a => ({
      id: a.socketId,
      username: a.username,
      status: a.status,
      currentCustomer: a.currentCustomer
    }));
  }

  function emitAgentList(io) {
    const list = getAgentList();
    console.log("ðŸ“¤ Emitting agent-list-update:", list);
    io.emit("agent-list-update", { agents: list });
  }
  
  function createChat(customerId, agentId) {
    const customerSocket = io.sockets.sockets.get(customerId);
    const agentSocket = io.sockets.sockets.get(agentId);
    
    if (!customerSocket || !agentSocket) return null;
    
    const chatId = `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const chat = {
      id: chatId,
      participants: [
        {
          id: customerId,
          username: customerSocket.username,
          role: "customer"
        },
        {
          id: agentId,
          username: agentSocket.username,
          role: "agent"
        }
      ],
      messages: [],
      startTime: new Date(),
      status: "active"
    };
    
    chats.push(chat);
    return chatId;
  }
  
  function findChatByParticipants(agentId, customerId) {
    return chats.find(chat => 
      chat.participants.some(p => p.id === agentId && p.role === "agent") &&
      chat.participants.some(p => p.id === customerId && p.role === "customer") &&
      chat.status === "active"
    );
  }
  
  function addMessageToChat(senderId, receiverId, message) {
    const chat = findChatByParticipants(
      senderId.role === "agent" ? senderId : receiverId,
      senderId.role === "customer" ? senderId : receiverId
    );
    
    if (chat) {
      chat.messages.push(message);
    }
  }
  
  function getChatHistoryForUser(userId, userRole) {
    return chats.filter(chat => 
      chat.participants.some(p => p.id === userId) ||
      (userRole === "agent" && chat.participants.some(p => p.role === "agent"))
    ).map(chat => ({
      ...chat,
      // Don't send full message history for performance, just the last few messages
      messages: chat.messages.slice(-10)
    }));
  }
  
  function getAllChats() {
    return chats.map(chat => ({
      ...chat,
      // Don't send full message history for performance
      messages: chat.messages.slice(-10)
    }));
  }
  
  function isUserInChat(userId, userRole, chat) {
    if (userRole === "admin") return true;
    return chat.participants.some(p => p.id === userId);
  }

  function findCustomerSocketByUsername(io, username) {
    const sockets = io.sockets.sockets;
    for (let [socketId, socket] of sockets) {
      if (socket.username === username && socket.role === "customer") {
        return socket;
      }
    }
    return null;
  }

  function now() {
    return new Date().toLocaleTimeString([], { 
      hour: "2-digit", 
      minute: "2-digit",
      second: "2-digit"
    });
  }
};
